# 网络连接的三种方式
## 桥接模式
使用桥接模式进行通讯需要把 IP 设置为同一网段，例如，192.168.0.11 和 192.168.0.12。这样会很容易造成 IP 冲突。
## NAT 模式
NAT 是网络地址转换模式，虚拟机可以和外部系统进行通讯，但是外部不可以和虚拟机进行通讯，不造成 IP 冲突。

## 主机模式
就是一个独立的系统，使用独立的 IP。

# 安装 VMTools 
Vmtools 可以使我们在 windous 下更好的管理 VM 虚拟机。
Vmtools 可以设置共享文件夹。

# Linux 目录结构
## 基本介绍
1. Linux 的文件系统是采用级层式的树状目录结构，在此结构中最上层的根目录是 / 。然在在此目录下创建其他目录。有一些目录是规定好的，不可以修改。
2. 深刻理解 linux 的树状文件目录是非常重要的，这里给大家说明一下
3. 记住一句经典的话：*在 Linux 世界里，一切皆文件。*


## 具体目录结构 
- /bin 【**常用**】 （/usr/bin，/usr/local/bin）是 Binary 的缩写，这个目录存放最常用的命令。

- /sbin （/usr/sbin，/usr/local/sbin） s 就是 super User 的意思，这里存放系统管理员使用的系统程序。

- /home 【常用】 存放普通用户的主目录，在 Linux 中每一个用户都有一个自己的目录，一般该目录是以用户的账号命名。

- /root [常用] 该目录为系统管理员，也称作超级权限者的用户主目录

- /lib 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库

- /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件

- /etc [常用] 所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my. conf

- /usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。
- /boot [常用] 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件
- /proc [不能动] 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息
- /srv [不能动] service 缩写，该目录存放一些服务启动之后需要提取的数据
- /sys [不能动]这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs =》【别动】
- /tmp 这个目录是用来存放一些临时文件的
- /dev 类似于 windows 的设备管理器，把所有的硬件用文件的形式存储
- /media [常用] linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下
-  /mnt [常用] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare
- /opt 这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空
- /usr/local [常用] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序
- /var [常用] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件
- /selinux [ security-enhanced linux ] SELinux 是一种安全子系统, 它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置.


# Vi 和 Vim 编辑器
## vi 和 vim 的基本介绍
Linux 系统会内置 vi 文本编辑器
Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

## vi 和 vim 常用的三种模式
### 正常模式
以 vim 打开一个档案就直接进入一般模式了 (这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。 
### 插入模式
按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可.
### 命令行模式
输入 esc 再输入：在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！  
## 各种模式的相互切换
![[imgs/Pasted image 20230311153029.png]]

## vi 和 vim 快捷键
### 快捷键使用练习
1) 拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴（输入 p）。
2) 删除当前行 dd , 删除当前行向下的 5 行 5dd 
3) 在文件中查找某个单词 【命令行下 /关键字，回车查找 , 输入 n 就是查找下一个 】
4) 设置文件的行号，取消文件的行号.【命令行下 : set nu 和 : set nonu】
5) 编辑 /etc/profile 文件，在一般模式下, 使用快捷键到该文档的最末行[G]和最首行[gg]
6) 在一个文件中输入 "hello" , 在一般模式下, 然后又撤销这个动作 u 
7) 编辑 /etc/profile 文件，在一般模式下, 并将光标移动到 , 输入 20, 再输入 shift+g 

![[imgs/Pasted image 20230311153956.png]]

# 开机、重启和用户登录注销
## 关机&重启命令
1) shutdown –h now 立该进行关机
2) shudown -h 1 "hello, 1 分钟后会关机了" , 会给 linux 用户发一条信息，说明一分钟后关机
3) shutdown –r now 现在重新启动计算机  
4) halt 关机，作用和上面一样.   
5) reboot 现在重新启动计算机  
6) sync 把内存的数据同步到磁盘. 
### 注意细节
1) 不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中 
2) 目前的 shutdown/reboot/halt 等命令均已经在关机前进行了 sync ，老韩提醒: 小心驶得万年船 

## 2 用户登录和注销
1) 登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su - 用户名’命令来切换成系统管理员身份. 
2) 在提示符下输入 logout 即可注销用户 

	logout 注销指令在图形运行级别无效，在运行级别 3 下有效

# 用户管理
## 基本介绍
Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 
## 添加用户
指令：useradd 用户名
当创建用户成功后，会自动的创建和用户同名的家目录，目录为/home/用户名
也可以通过 useradd -d 指定目录新的用户名，给新创建的用户指定家目录。例如 useradd -d /home/king123 king。
## 指定/修改密码
指令：passwd 用户名
如果不输入用户名代表是给当前用户修改密码。
显示当前用户所在目录 pwd
## 删除用户
指令：userdel 用户名（保留家目录）  userdel -r 用户名（不保留家目录）
## 查询用户信息指令
指令：id 用户名

## 切换用户
在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root
指令：su - 用户名
1. 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要
2. 当需要返回到原来用户时，使用 exit/logout 

## 查看当前用户/登录用户
指令：whoami 或者 who am I 
他只是显示第一次登陆到这个账户的信息。

## 用户组
类似于角色。系统可以对有共性/权限的多个用户进行统一的管理。
例如小明和小红有共同的权限，我们可以把小明和小红放到一个组，然后给这组赋值权限，这个组里的成员也就都获得了这个权限。

### 新增组
指令 : groupadd 组名

### 删除组
指令 (基本语法)： groupdel 组名

### 增加用户直接加上组
指令：useradd -g 用户组 用户名
当我们新增成员切没有指定组的时候，系统会自动创建同名组并放进去。

### 修改用户的组
指令：usermod -g 用户组 用户名

## 用户和组相关文件
### /etc/passwd 文件
用户（user）的配置文件，记录用户的各种信息 
每行的含义：**用户名: 口令: 用户标识号: 组标识号: 注释性描述: 主目录: 登录 Shell**
Shell 中的作用类似编译器，例如当我们向系统发送一条指令，回首先经过 shell 的解析，然后在发送给系统。

### /etc/shadow 文件
口令的配置文件
每行的含义：**登录名: 加密口令: 最后一次修改时间: 最小时间间隔: 最大时间间隔: 警告时间: 不活动时间: 失效时间: 标志**

### /etc/group 文件
组 (group) 的配置文件，记录 Linux 包含的组的信息
每行含义：**组名: 口令: 组标识号: 组内用户列表**

# 实用指令
##  指定运行级别
运行级别说明：
0 ：关机 
1 ：单用户【找回丢失密码】
2：多用户状态没有网络服务 
3：多用户状态有网络服务
4：系统未使用保留给用户 
5：图形界面 
6：系统重启 
常用运行级别是 3 和 5, 也可以指定默认运行级别，
命令：init [0123456] 应用案例： 通过 init 来切换不同的运行级别，比如动 5-3 ，然后关机。 

## CentOS7 后运行级别说明
在 centos7 以前， /etc/inittab 文件中 . 进行了简化，如下:  
multi-user. target: analogous to runlevel 3 
graphical. target: analogous to runlevel 5
//To view current default target,
run: systemctl get-default 
//To set a default target,
run: systemctl set-default TARGET . target

## 找回 root 密码 #面试题 
重启客户端，然后按 e 进入编辑模式 
![[imgs/Pasted image 20230311175950.png]]
找到图中红框的话，在最后输入 init=/bin/sh
写完之后，输入快捷键 ctrl+x，系统重启，进入单用户模式。
![[imgs/Pasted image 20230311180231.png]]
接着在光标闪烁的位置输入：mount -o remount,rw /   输入完成之后按下回车 

接着在新的一行输入：passwd
![[imgs/Pasted image 20230311180600.png]]
输入新的密码，长度大于 8 位，但不是必须的，输入完成会显示 passwd 的格式，表示修改成功

接着在最后一行输入：touch /.autorelabel
 ![[imgs/Pasted image 20230311180937.png]]
接着继续在新的一行输入：exec /sbin/init  等待系统自动修改密码并重启，这个过程时间有点长，耐心等待。

## 帮助指令
### man 获得帮助信息
基本语法：man [命令或配置文件]（功能描述：获得帮助信息）
案例：查看 ls 命令的帮助信息 man ls
在 linux 下，隐藏文件是以 . 开头 , **选项可以组合使用比如 ls -al, 比如 ls -al /root**  

### help 指令
基本语法：help 命令 （功能描述：获得 shell 内置命令的帮助信息）
案例：查看 cd 命令的帮助信息 

##  文件目录类
### pwd 指令
基本语法 ：pwd (功能描述：显示当前工作目录的绝对路径) 
应用实例：案例：显示当前工作目录的绝对路径 

### ls 指令
基本语法：ls 选项目录或是文件
常用选项 
-a ：显示当前目录所有的文件和目录，包括隐藏的。
-l ：以列表的方式显示信息

### cd 指令
基本语法：cd [参数] (功能描述：切换到指定目录) 
cd ~ 或者 cd ：回到自己的家目录, 比如你是 root ， cd ~ 到 /root 
cd .. 回到当前目录的上一级目录 
理解：绝对路径和相对路径 
绝对路径：从根目录去访问一个文件
相对路径：从当前位置去访问一个文件
例如： Hello. Txt 的绝对路径就是 /home/zml/Hello. Txt, 相对路径是：（前提我现在的位置在 zml 文件下）/zml/Hello. Txt。

应用实例
案例 1：使用绝对路径切换到 root 目录， cd /root 
案例 2: 使用相对路径到/root 目录, 比如在 /home/tom , cd ../../root 
案例 3：表示回到当前目录的上一级目录 , cd .. 
案例 4：回到家目录 , cd 

### mkdir 指令
mkdir 指令用于创建目录 
	基本语法：mkdir [选项] 要创建的目录
常用选项
	-p ：创建多级目录

### rmdir 指令删除空目录
基本语法：rmdir [选项] 要删除的空目录 
rmdir 删除的是空目录，如果目录下有内容时无法删除的。 
提示：如果需要删除非空目录，需要使用 rm -rf 要删除的目录比如： rm -rf 

### touch 指令 
touch 指令创建空文件
基本语法：touch 文件名称

### Cp 指令
cp 指令拷贝文件到指定目录 
基本语法：cp [选项] 复制的文件 被复制到的路径  
常用选项：
	-r ：递归复制整个文件夹，递归复制就是将这个路径下的文件全部复制过去。可以理解为复制文件夹

强制覆盖不提示的方法：\cp , \cp -r /home/bbb /opt 

### Rm 指令
说明：rm 指令移除文件或目录
基本语法：rm [选项] 要删除的文件或目录 
常用选项：
	-r ：递归删除整个文件夹
	-f ： 强制删除不提示

强制删除不提示的方法：带上 -f 参数即可
### Mv 指令
mv 移动文件与目录或重命名
基本语法：
	mv oldNameFile newNameFile (功能描述：重命名) 他们两个如果在同一目录则是重命名
	mv /temp/movefile /targetFolder (功能描述：移动文件)

### Cat 指令
cat 查看文件内容
基本语法：cat [选项] 要查看的文件
常用选项：
	-n ：显示行号
cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 | more 
cat -n /etc/profile | more [进行交互] 

### More 指令
more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键 (交互的指令)，详见操作说明
基本语法： more 要查看的文件

操作说明：
![[imgs/Pasted image 20230311191730.png]]

### less 指令
less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，*而是根据显示需要加载内容，对于显示大型文件具有较高的效率。*

基本语法： less 要查看的文件
操作说明：
![[imgs/Pasted image 20230311192238.png]]


### echo 指令
echo 输出内容到控制台
基本语法：echo [选项]  [输出内容]
案例: 使用 echo 指令输出环境变量, 比如输出 $PATH $HOSTNAME, echo $HOSTNAME 
案例: 使用 echo 指令输出 hello, world! Echo "helloworld"

### Head 指令
head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容 
基本语法：
	head 文件 (功能描述：查看文件头 10 行内容) 
	head -n 5 文件 (功能描述：查看文件头 5 行内容，5 可以是任意行数)

### Tail 指令
tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的前 10 行内容。
基本语法：
	1) tail 文件 （功能描述：查看文件尾 10 行内容）
	2) tail -n 5 文件 （功能描述：查看文件尾 5 行内容，5 可以是任意行数）
	3) 3) tail -f 文件 （功能描述：实时追踪该文档的所有更新）

案例 2: 实时监控 mydate. txt , 看看到文件有变化时，是否看到，实时的追加 hello, world
tail -f /home/mydate. txt

###    >   指令和 >>  指令
 >  输出重定向和 >> 追加
 
---
一个箭头是覆盖写，两个箭头是追加写。
基本语法：
	1) ls -l >文件 （功能描述：列表的内容写入文件 a.txt 中（覆盖写））
	2) ls -al >>文件 （功能描述：列表的内容追加到文件 aa. txt 的末尾）
	3) cat 文件 1 > 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2）
	4) 4) echo "内容">> 文件 (追加)

案例 1: 将 /home 目录下的文件列表写入到 /home/info. txt 中, 覆盖写入 
ls -l /home > /home/info. txt [如果 info. txt 没有，则会创建]

### Ln 指令
软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径 
基本语法：
	ln -s [原文件或目录]  [ 软链接名 ] （功能描述：给原文件创建一个软链接）

案例 1: 在/home 目录下创建一个软连接 myroot，连接到 /root 目录
ln -s /root /home/myroot
**当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。**

### history 指令
查看已经执行过历史命令, 也可以执行历史指令 
基本语法：
	history 

案例 2: 显示最近使用过的 10 个指令。   history 10
案例 3：执行历史编号为 5 的指令   ! 5

## 时间日期类
### date 指令 - 显示当前日期
基本语法：
	1) date （功能描述：显示当前时间）
	2)  date +%Y（功能描述：显示当前年份）
	3)  date +%m（功能描述：显示当前月份）
	4)  date +%d （功能描述：显示当前是哪一天）
	5) date "+%Y-%m-%d %H:%M:%S"（功能描述：显示年月日时分秒）

### date 指令-设置日期
基本语法：date -s 字符串时间
案例 1: 设置系统当前时间，比如设置成 2020-11-03 20:02 : 10 
date -s “2020-11-03 20:02 : 10”

### cal 指令
查看日历指令 cal 
基本语法： cal [选项] （功能描述：不加选项，显示本月日历）
案例 2: 显示 2020 年日历 : cal 2020 

## 搜索查找类
### find 指令
find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 
基本语法：find [搜索范围]  [ 选项 ]
选项说明：
![[imgs/Pasted image 20230312135412.png]]

案例 1: 按文件名：根据名称查找/home 目录下的 hello. txt 文件 
find /home -name hello.txt
案例 2：按拥有者：查找/opt 目录下，用户名称为 nobody 的文件 
find /opt -user nobody
案例 3：查找整个 linux 系统下大于 200M 的文件（+n 大于 -n 小于 n 等于, 单位有 k, M, G）
find / -size +200M

### locate 指令
locate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻 
**基本语法：locate 搜索文件**

- 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库 


### which 指令，
可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录 which ls 

### grep 指令和管道符号
grep 过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 
基本语法： grep [选项] 查找内容 源文件
常用选项：
![[imgs/Pasted image 20230312140830.png]]

案例 1: 请在 hello. txt 文件中，查找 "yes" 所在行，并且显示行号
cat /home/hello.txt | grep "yes
## 压缩和解压类
### gzip/gunzip 指令
gzip 用于压缩文件， gunzip 用于解压的 
基本语法：
	gzip 文件 （功能描述：压缩文件，只能将文件压缩为*. gz 文件）
	gunzip 文件. gz （功能描述：解压缩文件命令） 

### zip/unzip 指令
zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的，可以用来解压压缩文件夹
基本语法：
	zip [选项] XXX. zip 将要压缩的内容（功能描述：压缩文件和目录的命令）
	unzip [选项] XXX. zip （功能描述：解压缩文件）

Zip 常用选项：-r：递归压缩，即压缩目录
Unzip 常用选项：-d<目录> ：指定解压后文件的存放目录 

案例 1: 将 /home 下的所有文件/文件夹进行压缩成 myhome. zip
zip -r myhome.zip /home/ [将 home 目录及其包含的文件和子文件夹都压缩]
案例 2: 将 myhome. zip 解压到 /opt/tmp 目录下
unzip -d /opt/tmp /home/myhome.zip

### tar 指令
tar 指令是打包指令，最后打包后的文件是 .tar. gz 的文件。 
基本语法：tar [选项] XXX. tar. gz 打包的内容 (功能描述：打包目录，压缩后的文件格式. tar. gz)
选项说明：
-c 表示：打包成 tar 文件
-x 表示：解包 tar 文件
**-z 表示：使用 gzip 对文件压缩或者解压** 
-f 表示：指定备份文件
案例 1: 压缩多个文件，将 /home/pig. txt 和 /home/cat. txt 压缩成 pc. tar. gz 
tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt
案例 3: 将 pc. tar. gz 解压到当前目录
tar -zxvf pc. tar. gz
案例 4: 将 myhome. tar. gz 解压到 /opt/tmp2 目录下
(1) mkdir /opt/tmp2 (2) tar -zxvf /home/myhome.tar.gz -C /opt/tmp2

# 组管理和权限管理
## Linux 组基本介绍
在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。 
一个文件有下面几种概念，其中其他组的可以理解为除所在组之外的的组，被称为其他组。
1) 所有者 
2) 所在组 
3) 其它组 
4) 改变用户所在的组


## 文件/目录所有者
一般为文件的创建者, 谁创建了该文件，就自然的成为该文件的所有者。 

### 查看文件的所有者
指令：ls –ahl
![[imgs/Pasted image 20230312153545.png]]

### 修改文件所有者
指令：chown 用户名 文件名 
要求：使用 root 创建一个文件 apple. txt ，然后将其所有者修改成 tom
chown tom apple.txt

## 组的创建
基本语法： groupadd 组名
创建一个组, ,monster 创建一个用户 fox ，并放入到 monster 组中
groupadd monster
useradd -g monster fox

## 文件/目录所在组
当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 (默认)。 

### 查看文件/目录所在组
基本语法：
	ls –ah

### 修改文件/目录所在的组
基本语法：chgrp 组名文件名

## 其它组
除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。

## 改变用户所在组
在用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组。 

### 改变用户所在组
基本语法：
	usermod –g 新组名 用户名
	usermod –d 目录名 用户名   改变该用户登陆的初始目录。特别说明：用户需要有进入到新目录的权限。

将 zwj 这个用户从原来所在组，修改到 wudang 组
usermod -g wudang zw 

## 权限的基本介绍
ls -l 中显示的内容如下：
-rwxrw-r-- 1 root root 1213 Feb 2 09:39 ab 
0-9 位说明：
	第 0 位确定文件类型 （d,-, l, c, b）
		l 是链接，相当于 windows 的快捷方式
		d 是目录，相当于 windows 的文件夹
		 c 是字符设备文件，鼠标，键盘
		b 是块设备，比如硬盘
		- 是普通文件
	第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。---User
	第 4-6 位确定所属组（同用户组的）拥有该文件的权限，---Group
	第 7-9 位确定其他用户拥有该文件的权限 ---Othe 

## rwx 权限详解
### rwx 作用到文件
1) [ r ]代表可读 (read): 可以读取, 查看
2)  [ w ]代表可写 (write): 可以修改, 但是不代表可以删除该文件, 删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件. 
3) [ x ]代表可执行 (execute): 可以被执行


### rwx 作用到目录
**rwx作用于目录的权限与文件有些不同**
1) [ r ]代表可读 (read): 可以读取，ls 查看目录内容
2) [ w ]代表可写 (write): 可以修改, 对目录内创建+删除+重命名目录
3) [ x ]代表可执行 (execute): 可以进入该目录

一个用户对于目录的权限不会影响到里面的文件的权限。例如 用户a 对于 lib 目录的权限只有 x 权限，但是对于里面的文件有 r 和 w 权限，a 用户 依然可以进入lib 目录 去操作 里面的文件。
| 权限 | 作用                       |
| ---- | -------------------------- |
| x    | 表示可以进入该目录 比如 cd |
| r    | 表示可以ls                 |
| w    | 表示可以在该目录删除或者创建文件   |


## 文件及目录权限实际案例
ls -l 中显示的内容如下：
-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc
10 个字符确定不同用户能对文件干什么？
第一个字符代表文件类型： - l d c b 
其余字符每 3 个一组 (rwx) 读 (r) 写 (w) 执行 (x) 
第一组 rwx : 文件拥有者的权限是读、写和执行 
第二组 rw- : 与文件拥有者同一组的用户的权限是读、写但不能执行 
第三组 r-- : 不与文件拥有者同组的其他用户的权限是读不能写和执行

可用数字表示为: r=4, w=2, x=1 因此 rwx=4+2+1=7 , 数字可以进行组 
其他说明：
| 名字        | 作用                                           |
| ----------- | ---------------------------------------------- |
| 1           | 显示目录下的子目录数的总和，包括隐藏目录       |
| root        | 用户                                           |
| root        | 文件所在组                                     |
| 1213        | 文件大小（字节），如果是文件夹，显示 4096 字节 |
| Feb 2 09:39 | 最后修改的日期                                 |
| abc         | 文件名                                         |

## 修改权限-chmod
基本说明：
通过 chmod 指令，可以修改文件或者目录的权限。 
### 第一种方式：+ 、-、= 变更权限
***u: 所有者 g: 所有组 o: 其他人 a: 所有人 (u、g、o 的总和)*** 

1) chmod u=rwx, g=rx, o=x  文件/目录名。所有者赋予读写执行权限，所在组赋予读和执行权限，其他人赋予执行权限。
2) chmod o+w 文件/目录名。给所有组赋予写权限。
3) chmod a-x 文件/目录名。给所有人去除执行权限。

给 abc 文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。
chmod u=rwx, g=rx, o=rx abc

### 第二种方式：通过数字变更权限
r=4 w=2 x=1 rwx=4+2+1=7 
chmod u=rwx, g=rx, o=x 文件目录名
相当于 chmod 751 文件/目录 

要求：将 /home/abc. txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现：
chmod 755 /home/abc. txt

### 修改文件所有者-chown
基本语法：
	chown newowner 文件/目录改变所有者
	chown newowner: newgroup 文件/目录      改变所有者和所在组
-R 如果是目录，则使其下所有子文件或目录递归生

请将 /home/test 目录下所有的文件和目录的所有者都修改成 tom 
chown -R tom /home/te

### 修改文件/目录所在组-chgrp
基本语法：chgrp newgroup 文件/目录 【 改变所在组】
-R 将该目录下所有文件的组进行修改

请将 /home/test 目录下所有的文件和目录的所在组都修改成 shaolin (少林) 
chgrp -R shaolin /home/test

# 定时任务调度
对一些指令的自动调用。

## crond 任务调度
***crontab 进行 定时任务的设置。***
任务调度：是指系统在某个时间执行的特定的命令或程序。 
任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 
个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。 
示意图：
![[imgs/Pasted image 20230312190210.png]]

基本语法：
crontab [选项] 
常用选项：
| 选项 | 作用                  |
| ---- | --------------------- |
| -e   | 编辑 crontab 定时任务 |
| -l   | 编辑 crontab 任务     |
| -r   | 删除当前用户所有的 crontab                       |

快速入门：
设置任务调度文件：/etc/crontab 
设置个人任务调度。执行 crontab –e 命令。
接着输入任务到调度文件 如：
```
*/1 * * * * ls –l /etc/ > /tmp/to.txt 
意思说每小时的每分钟执行 ls –l /etc/ > /tmp/to.txt
```

参数细节说明 
5 个占位符的说明
![[imgs/Pasted image 20230313175037.png]]

特殊符号说明：
![[imgs/Pasted image 20230313175055.png]]

特殊时间执行案例：
![[imgs/Pasted image 20230313175113.png]]

可以使用类似的网站生成时间表达式

案例 1：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中 
```
 */1 * * * * date
```

案例 2：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal
```
步骤: (1) vim /home/my.sh 写入内容 date >> /home/mycal 和 cal >> /home/mycal 
(2) 给 my.sh 增加执行权限，chmod u+x /home/my.sh 
(3) crontab -e 增加 */1 * * * * /home/my
```

crond 相关指令：
	conrtab –r：终止任务调度。
	crontab –l：列出当前有那些任务调度
	service crond restart [ 重启任务调度 ]

## at 定时任务
1) at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行。 
2) 默认情况下，atd 守护进程每 60 秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则 运行此作业。
3) at 命令是一次性定时计划任务，执行完一个任务后不再执行此任务了 
4) 在使用 at 命令的时候，一定要保证 atd 进程的启动 , 可以使用相关指令来查看。
5) ps -ef | grep atd     可以检测 atd 是否在运行。


atd会对作业队列每 60s 检查一次，当发现有可以执行的作业就回去执行作业。且只会执行一次。没有可执行作业也就不会有其他作业。
![[imgs/Pasted image 20230313181458.png]]

基本指令：
	at [选项]  [时间]
	Ctrl + D 结束 at 命令的输入，需要输入两次才可以退出。

命令选项：
![[imgs/Pasted image 20230313181821.png]]

### at时间定义
at制定时间的方法：
1) 接受在当天的 hh:mm（小时: 分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。例如： 04:00 
 2) 使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午 4 点）等比较模糊的词语来指定时间。 
3) 采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。例如：12pm
4) 指定命令执行的具体日期，指定格式为 month day（月日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日. 月. 年），指定的日期必须跟在指定时间的后面。例如： 04:00 2021-03-1 
5) 使用相对计时法。指定格式为：now + count time-units ，now 就是当前时间，time-units 是时间单位，这里能够是 minutes （分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，几天，几小时。例如：now + 5 minute 
6) 直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。 


案例 1：2 天后的下午 5 点执行 /bin/ls /home
```
at 5pm + 2days
/bin/ls /home 
```

atq 命令来查看系统中没有执行的工作任务 
```
查看没有执行的作业队列
atq
```

案例 3：明天 17 点钟，输出时间到指定文件内 比如 /root/date100.log
```
at 5pm tomorrow 
date > /root/date100.log
```

案例 4：2 分钟后，输出时间到指定文件内 比如 /root/date200.log
```
at now + 2minutes
date > /root/date100.log
```

案例 5：删除已经设置的任务 , atrm 编号
```
atrm 4 
//表示将 job 队列，编号为 4 的 job 删除.
```

# Linux 磁盘分区、挂载
## Linux 分区
### 原理介绍
1) Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。
2) Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录 联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。
3) 示意图![[imgs/Pasted image 20230313190005.png]]

### 硬盘说明
1) Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘  
2) 对于 IDE 硬盘，驱动器标识符为“hdx~”, 其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“~”代表分区，前四个分区用数字 1 到 4 表示，他们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区, hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。 
3) 对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样 


查看所有设备挂载情况：
```
命令 ：lsblk 或者 lsblk -f
```

## 新增硬盘操作
### 1 增加硬盘 
![[imgs/Pasted image 20230313194419.png]]


### 2 硬盘分区
 分区命令 
```
fdisk /dev/sdb 
```

| 指令 | 作用                      |
| ---- | ------------------------- |
| m    | 显示命令列表              |
| p    | 显示磁盘分区，同 fdisk -l |
| n    | 新增分区                  |
| d    | 删除分区                  |
| w    | 写入并退出                |
| q    | 退出，并不保存操作                          |

### 3 格式化磁盘
分区命令
```
mkfs -t ext4 /dev/sdb1
将 dev sdb1这个 磁盘格式化
其中 ext4 是分区类型
```

### 4 挂载磁盘
挂载: 将一个分区与一个目录联系起来
挂载指令：
```
mount 设备名称 挂载目录
例如： mount /dev/sdb1 /new
```

卸载挂载指令：
```
umount 设备名称 或者 挂载目录
例如： umount /dev/sdb1 或者 umount /newdisk
```
 
**用命令行挂载, 重启后会失效**

### 永久挂载磁盘方法
永久挂载: 通过修改/etc/fstab 实现挂载 
添加完成后执行 mount –a 即刻生效 
添加新的一行即可。
![[imgs/Pasted image 20230313200053.png]]

## 磁盘情况查询
### 查询系统整体磁盘使用情况
基本语法：
```
df -h
```

### 查询指定目录的磁盘占用情况
基本语法：
```
du -h  目录
如果不带目录则默认查询所在位置占用空间
```

| 参数          | 作用                                     |
| ------------- | ---------------------------------------- |
| -s            | 制定目录占用大小汇总                     |
| -h            | 带计量单位（G，MB..）                    |
| -a            | 含文件                                   |
| --max-depth=1 | 表示查询子目录深度，这里查询第一层子目录 |
| -c            | 列出明细的同时，增加汇总量                                         |

查询 /opt 目录的磁盘占用情况，深度为 1
```
du -hac --max-depth=1 /opt
```

## 磁盘情况-工作实用指令
统计/opt 文件夹下文件的个数
```
ls -l /opt | grep "^-" | wc -l
先过滤出是普通文件的文件，（普通文件以-开头），然后在使用wc统计个数
grep指令支持正则表达式。
```

统计/opt 文件夹下目录的个数
```
s -l /opt | grep "^d" | w
先过滤出是普通文件的文件，（普通目录以d开头），然后在使用wc统计个数
```

统计/opt 文件夹下文件的个数，包括子文件夹里的
```
ls -lR /opt | grep "^-" |
```

统计/opt 文件夹下目录的个数，包括子文件夹里的
```
ls -lR /opt | grep "^d" |
```

以树状显示目录结构 tree 目录，注意，如果没有 tree ,则使用 yum install tree 安装
```
tree 路径
```

# 网络配置
## Linux 网络配置原理图
网络配置原理图
![[imgs/Pasted image 20230313210242.png]]

虚拟机通过 vm8 在通过无线网卡，在通过网关，最终访问到了互联网 

## 查看网络 IP 和网关
![[imgs/Pasted image 20230313211155.png]]

或者使用 ifconfig 指令 

## ping 测试主机之间网络连通性
基本语法 
ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）

## linux 网络环境配置
### 第一种方法 (自动获取)：
说明：登陆后，通过界面的来设置自动获取 ip，特点：linux 启动后会自动获取 IP, 缺点是每次自动获取的 ip 地址可能不一样。
这样是不可以作为服务器的，因为每次重启 ip 地址就会改变。

在 linux 系统中打开网络设置即可查看。
![[imgs/Pasted image 20230313211424.png]]

### 第二种方法 (指定 ip)
说明： 直接修改配置文件来指定 IP, 并可以连接到外网 (程序员推荐）
编辑文件：
~~~
vi /etc/sysconfig/network-scripts/ifcfg-ens33
要求：将 ip 地址配置的静态的，比如: ip 地址为 192.168.200.130
~~~

ifcfg-ens33 文件说明：
 ~~~
 #接口名（设备,网卡）
 DEVICE=eth0  
 #网络类型（通常是 Ethemet） 
 HWADDR=00:0C:2x:6x:0x:xx #MAC 地址 TYPE=Ethernet 
#随机 id 
 UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44 
 #系统启动的时候网络接口是否有效（yes/no） 
 ONBOOT=yes 
 # IP 的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配 IP|BOOTP
BOOTPROTO=static 
#IP 地址
IPADDR=192.168.200.130 
#网关 
GATEWAY=192.168.200.2
#域名解析器 
DNS1=192.168.200.2
 ~~~

重启网络服务或者重启系统是配置生效
~~~
service network restart  重启网络服务
reboot  重启系统
~~~

## 设置主机名和 hosts 映射
### 设置主机名
为了方便记忆，可以给 linux 系统设置主机名, 也可以根据需要修改主机名
指令 
~~~
hostname   查看主机名
~~~
修改文件在 /etc/hostname 指定
修改后，重启生效

### 设置 hosts 映射
思考：如何通过主机名能够找到 (比如 ping) 某个 linux 系统？
需要将主机名和 ip 进行映射让系统可以识别。

windows：
~~~
在 C:\Windows\System32\drivers\etc\hosts 文件指定即可
~~~

linux：
```
在 /etc/hosts 文件 指定
例如：192.168.200.1 ThinkPad-PC
```

## 主机名解析过程分析 (Hosts、DNS)
### Hosts 是什么？
一个文本文件，用来记录 IP 和 Hostname (主机名)的映射关系 

### DNS 是什么
DNS，就是 Domain Name System 的缩写，翻译过来就是域名系统是互联网上作为域名和 IP 地址相互映射的一个分布式数据库

### 解析应用实例: 用户在浏览器输入了  www.baidu.com  
1. 浏览器先检查浏览器缓存中有没有该域名解析 IP 地址，有就先调用这个 IP 完成解析；如果没有，就检查本地 DNS 解析器缓存，如果有直接返回 IP 完成解析。这两个缓存，可以理解为本地解析器缓 
2. 一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的 IP 地址（DNS 解析记录）. 如在 cmd 窗口中输 
3. ipconfig /displaydns //DNS 域名解析缓存
4. ipconfig /flushdns //手动清理 dns 缓存
5. 如果本地解析器缓存没有找到对应映射，检查系统中 hosts 文件中有没有配置对应的域名 IP 映射，如果有，则完成解析并返回。
6. 如果本地 DNS 解析器缓存和 hosts 文件中均没有找到对应的 IP，则到域名服务 DNS 进行解析


主机 ——》检查浏览器缓存 ——》检查电脑本地 dns 缓存——》检查系统 hosts 文件——》检查 DNS 服务解析，如果都没有查找到，则返回域名不存在。

示意图：
![[imgs/Pasted image 20230314152105.png]]

# 进程管理 (重点)
## 基本介绍
- 在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号，(pid, 进程号)。
- 每个进程都可能以两种方式存在的。**前台与后台**，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行 
- 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。

程序是静态的说法，当一段程序运行起来，就会存在于内存之中，形成一个进程。

## 显示系统执行的进程
## Ps 命令
ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数.

常用参数：
| 参数 | 作用                   |
| ---- | ---------------------- |
| -a   | 显示当前终端的所有进程 |
| -u   | 以用户的形式显示信息   |
| -x   | 显示后台运行的进程参数                       |

![[imgs/Pasted image 20230314154044.png]]
进程参数：
| 参数    | 作用                        |
| ------- | --------------------------- |
| user    | 进程执行用户                |
| PID     | 进程号                      |
| %CPU    | 占用 CPU 的百分比           |
| %MEM    | 占用物理内存的百分比        |
| VSZ     | 占用虚拟内存单位KB              |
| RSS     | 占用实际内存单位 KB              |
| TTY     | 运行的终端号                |
| STAT    | 运行状态 s 表示休眠，r 运行 |
| START   | 进程的执行开始时间          |
| TIME    | 占用 CPU 总时间               |
| COMMAND | 启动该进程的指令/进程名                            |
STAT 进程状态：
| 参数 | 解析                                 |
| ---- | ------------------------------------ |
| S    | 睡眠                                 |
| s    | 表示该进程是会话的先导进程           |
| N   | 表示进程拥有比普通优先级更低的优先级 |
| R    | 正在运行                             |
| D    | 短期等待                             |
| Z    | 僵死进程                             |
| T    | 被跟踪或者被停止等等                                     |

要求：以全格式显示当前所有的进程，查看进程的父进程。查看 sshd 的父进程信息
```
ps -ef 
是以全格式显示当前所有的进程 
-e 显示所有进程。-f 全格式
```
是 BSD 风格
- UID：用户 ID 
- PID：进程 ID 
- PPID：父进程 ID
- C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高 
- STIME：进程启动的时间 
- TTY：完整的终端名称 
- TIME：CPU 时间 
- CMD：启动进程所用的命令和参数


## 终止进程 kill 和 killal
若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。 
基本语法：
```
kill [选项] 进程号
（功能描述：通过进程号杀死/终止进程） 
killall 进程名称 
（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）
```

常用选项：
```
-9 表示强迫进程立即停止
```

 案例 1：踢掉某个非法登录用户
```
通过 ps -aux | grep sshd 来查看用户登录的进程。
kill 进程号 , 比如 kill 11421
```

案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务
```
kill sshd 对应的进程号;
/bin/systemctl start sshd.service  启动sshd服务
```

案例 3: 终止多个 gedit , 演示 
```
killall gedit
所有的gedit进程都会被杀死
```

## 查看进程树 pstree
基本语法：
```
pstree [选项] 
可以更加直观的来看进程信息
```

常用选项：
| 参数 | 作用         |
| ---- | ------------ |
| -p   | 显示进程 PID |
| -u   | 显示所属用户             |

## 服务 (service)管理
服务 (service) 本质就是**进程**，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如 (mysqld , sshd 防火墙等)，**因此我们又称为守护进程**，是 Linux 中非常重要的知识点。

Service 管理指令
```
1）service 服务名 [start | stop | restart | reload | status] 
2) 在 CentOS7.0 后 很多服务不再使用 service ,而是 systemctl 
3) service 指令管理的服务在 /etc/init.d 查看
```


### 查看服务名 
使用 setup -> 系统服务就可以看到全部。按 tab 键退出。
![[imgs/Pasted image 20230315181557.png]]

空格键选择开启自启。

查看 /etc/init. d 看到 service 指令管理系统
```
ls -l /etc/init.d
```

### 服务的运行级别 (runlevel)
 服务的运行级别 (runlevel):
- 运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动
- 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆 
- 运行级别 2：多用户状态 (没有 NFS)，不支持网络 
- 运行级别 3：完全的多用户状态 (有 NFS)，无界面，登陆后进入控制台命令行模式 
- 运行级别 4：系统未使用，保留 
- 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式 
- 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启


开机流程：
![[imgs/Pasted image 20230315181906.png]]

### CentOS7 后运行级别说明
Cetos 7 对运行级别做出了简化
在 /etc/inita 中
```
multi-user.target: analogous to runlevel 3
运行级别3
graphical.target: analogous to runlevel 5
运行级别5
```

查看当前运行级别
```
systemctl get-default
```

设置当前运行级别
```
systemctl set-default 运行级别
```

### 服务自启动设置
通过 chkconfig 命令可以给*服务的各个运行级别设置自启动/关闭* 
chkconfig 指令管理的服务在 `/etc/init.d` 查看 
注意: Centos7.0 后，很多服务使用 `systemctl` 管理

`chkconfig` 基本语法：
```
# 查看 checonfig 管理的服务
chkconfig --list [| grep xxx]
# 查看具体服务的自启动设置
chkconfig 服务名 --list
# 设置某个服务在某个运行级别的自启动或者关闭
chkconfig --level 5 服务名 on/off
```


### systemctl 管理指令
基本语法：
```
systemctl [start | stop | restart | status] 服务名
管理具体一条服务的状态
```

systemctl 指令管理的服务在 /usr/lib/systemd/system 查看

systemctl 设置服务的自启动状态：
```
systemctl list-unit-files [ | grep 服务名] 
(查看服务开机启动状态, grep 可以进行过滤)
systemctl enable 服务名 (设置服务开机启动)
systemctl disable 服务名 (关闭服务开机启动)
systemctl is-enabled 服务名 (查询某个服务是否是自启动的)

因为centos7简化了运行级别，所以上面这些指令就是控制了3和5的运行级别。
```

细节讨论：
关闭或者启用防火墙后，立即生效。`[telnet 测试某个端口即可] `
这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。
如果希望设置某个服务自启动或关闭永久生效，要使用 `systemctl [enable|disable] 服务名`

### 打开或者关闭指定端口
在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如 80、22、8080 等。

#### firewall 指令
**打开或者关闭端口，需要重新载入才会生效。**
```
1) 打开端口: firewall-cmd --permanent --add-port=端口号/协议 
2) 关闭端口: firewall-cmd --permanent --remove-port=端口号/协议 
3) 重新载入,才能生效 : firewall-cmd --reload 
4) 查询端口是否开放: firewall-cmd --query-port=端口/协议
```


## 动态监控进程
top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程，他是一种动态的监控。

基本语法：
```
top [选项]
```

Top 值详解：
![[imgs/Pasted image 20230315200301.png]]

选项说明：
| 参数    | 作用                                 |     |
| ------- | ------------------------------------ | --- |
| -d 秒数 | 制定 top 命令刷新的频率，默认是 3 秒 |     |
| -i      | 使 top 不显示任何闲置或者僵死的进程  |     |
| -p      | 通过指定监控进程 id 来仅仅监控某个进程的状态                                     |     |

交互操作说明：
| 操作 | 功能                          |
| ---- | ----------------------------- |
| P    | 以 CPU 的频率排序，默认是此项 |
| M    | 以内存的使用率排序            |
| N    | 以 PID 排序                   |
| q    | 退出 TOP                      |
| u    | 查看指定进程                  |
| k    | 杀死指定进程                              |

案例 1. 监视特定用户, 比如我们监控 tom 用户
```
top：输入此命令，按回车键，查看执行的进程。 u：然后输入“u”回车，再输入用户名，即可
```

案例 2：终止指定的进程, 比如我们要结束 tom 登录
```
top：输入此命令，按回车键，查看执行的进程。 k：然后输入“k”回车，再输入要结束的进程 ID 号
```

## 监控网络状态
### 查看系统网络情况 netstat
基本语法：
```
netstat [选项]
```

选项说明：
| 参数 | 作用               |
| ---- | ------------------ |
| -an  | 按一定顺序排列输出 |
| -p   | 显示那个进程在调用                   |

请查看服务名为 sshd 的服务的信息。 
```
netstat -anp | grep sshd
```

外部地址和本地地址
![[imgs/Pasted image 20230315202318.png]]
**当我们的一条连接断开之后，他并不会立刻停止，而是会有一个超时等待，这是 TCp 协议的特点。一般是一分钟。**

### 检测主机连接命令 ping
是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。如: ping 对方 ip 地址


# RPM 与 YUM
## rpm 包的管理
rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有. RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup. exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。
Linux 的分发版本都有采用（suse, redhat, centos 等等），可以算是公认的行业标准了。

### rpm 包的简单查询指令
查询已安装的 rpm 列表：
```
rpm –qa|grep xx
```

举例： 看看当前系统，是否安装了 firefox
```
rpm -qa | grep firefox
```

### rpm 包名基本格式
一个 rpm 包名：firefox-60.2.2-1. el7. centos. x86_64。
解析：
- 名称:firefox
- 版本号：60.2.2-1
- 适用操作系统: el7. centos. x86_64
- 表示 centos7. x 的 64 位系统，如果是 i686、i386 表示 32 位系统，noarch 表示通用


### rpm 包的其它查询指令
```
查询所安装的所有 rpm 软件包
rpm -qa 
rpm -qa | more  使用分页
rpm -qa | grep X [rpm -qa | grep firefox ]  使用过滤

查询软件包是否安装
rpm -q 软件包名 
案例：rpm -q firefox

rpm -qi 软件包名  ：查询软件包信息
案例: rpm -qi firefox

rpm -ql 软件包名  :查询软件包中的文件
比如： rpm -ql firefox

查询文件所属的软件包
rpm -qf 文件全路径名 
举例：
	rpm -qf /etc/passwd
	rpm -qf /root/install.log
```
 
### 卸载 rpm 包
基本语法：
```
rpm -e RPM包的名称
```

如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。 
```
如：$ rpm -e foo
```

removing these packages would break dependencies: foo is needed by bar-1.0-1
如果我们就是要删除 foo 这个 rpm 包，可以增加参数 --nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。
```
如：$ rpm -e --nodeps foo
```

### 安装 rpm 包
基本语法：
```
rpm -ivh RPM包全路径名称
```

参数说明：
| 参数 | 作用         |
| ---- | ------------ |
| i    | install 安装 |
| v    | verbose 提示 |
| h    | hash 进度条         | 

## yum
Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动
下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。 

### yum 的基本指令
查询 yum 服务器是否有需要安装的软件
```
Yum list|grep xx 软件列表
```

### 安装指定的 yum 包
下载安装：
```
Yum install xxx
```

# JavaEE 定制篇-搭建 JavaEE 环境

# Shell 编程
## Shell 是什么
Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。 

## Shell 脚本的执行方式
脚本以 `#！/bin/bash` 开头
脚本需要具有可执行权限。

### 快速入门
编写一个 shell 脚本，输出 Hello World！

```
1. vim hello.sh
2. 编写脚本
	#!/bin/bash
	echo "hellom,world"
3. 赋予运行权限， 使用./hello.sh 运行 也可以是用绝对路径执行：/root/shcode/Hello.sh
4. 其他运行方式：（可以不赋予运行权限） 直接使用 sh 脚本名称
```

## Shell 的变量
 Linux Shell 中的变量分为，系统变量和用户自定义变量。
```
2. 系统变量：$HOME、$PWD、$SHELL、$USER 等等，比如： echo $HOME
等等..
```
显示当前 shell 中所有变量：set

### shell 变量的定义
基本语法：
	定义变量：变量名=值
	撤销变量：unset 变量
	声明静态变量：readonly 变量，注意：不能 unset

定义变量的规则：
	变量名称可以由字母、数字和下划线组成，但是不能以数字开头。5A=200 (×)
	等号两侧不能有空格
	变量名称一般习惯为大写，这是一个规范，我们遵守即可

将命令的返回值赋给变量：
```
A=`date`反引号，运行里面的命令，并把结果返回给变量 A
A=$(date) 等价于反引号
```

案例：定义变量 A，撤销变量 A，声明静态的变量 B=2，不能 unset


```
#!/bin/bash
A=100
echo $A
unset A
echo $A
readonly B=200
echo $B
```

## 设置环境变量
基本语法：
	export 变量名=变量值 （功能描述：将 shell 变量输出为环境变量/全局变量）
	Source 配置文件（功能描述：让修改后的配置信息立即生效）
	Echo $变量名（功能描述：查询环境变量的值）

### 快速入门
在 etc/profile 中定义一个自定义全局变量
![[imgs/Pasted image 20230323174230.png]]
可以在 sh 脚本中使用这个全局变量

**shell 脚本的多行注释，需要单独一行**
```
:<<! 
内容 
!
```

## 位置参数变量
当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量 
比如 ： ./myshell. Sh 100 200 , 这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息

基本语法：
```
$n （功能描述：n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）

$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）

$@（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）

$#（功能描述：这个变量代表命令行中所有参数的个数）
```

案列：编写脚本查看各种方式
```
sh test2.sh 100 200

脚本内容：
#!/bin/bash
echo "$0,$1"
echo "$*"
echo "$@"
echo "$#"
```

## 预定义变量
就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用 

基本语法：
```
$$ （功能描述：当前进程的进程号（PID））
$! （功能描述：后台运行的最后一个进程的进程号（PID））
$？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变
量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）
```

案例：简单使用下预定义变量
```
#!/bin/bash
echo $$
# 后台方式运行一个脚本
/root/shcode/test.sh &
echo $!
echo $?
```

## 运算符
shell 中进行各种运算操作。

基本语法：
```
“$((运算式))”或“$[运算式]”或者 expr m + n //expression 表达式

注意 expr 运算符间要有空格, 如果希望将 expr 的结果赋给某个变量，使用 ``

expr m - n

expr \*,/,%    乘，除，取余
```

计算（2+3）X4 的值推荐使用 $[ ]：
请求出命令行的两个参数[ 整数 ]的和 20 50
```
#!/bin/bash
#第一种方式
RES1=$(((2+3)*4))
echo $RES1
#第二种方式
RES2=$[(2+3)*4]
echo $RES2
#第三种方式
TEMP=`expr 2 + 3`
RES3=`expr TEMP \* 4 `
echo $RES3

请求出命令行的两个参数[ 整数 ]的和 20 50
SUM=$[$1+$2]
echo $SUM
```

## 条件判断
 基本语法：
```
[ condition ]（注意 condition 前后要有空格）
#非空返回 true，可使用$?验证（0 为 true，>1 为 false）
if开头，fi结尾

```

常用判断语句：
	= 字符串比较
	 两个整数的比较
	 -lt 小于
	 -le 小于等于 little equal
	 -eq 等于
	 -gt 大于
	 -ge 大于等于
	 -ne 不等于

文件权限判断：
	-r 有读的权限
	-w 有写的权限
	-x 有执行的权限

按照文件类型进行判断：
	-f 文件存在并且是一个常规的文件
	-e 文件存在
	-d 文件存在并是一个目录

案例：
![[imgs/Pasted image 20230323191348.png]]


## 流程控制
### if 判断
基本语法：
```
if [ 条件判断式 ]
then
代码
fi

或者 , 多分支

if [ 条件判断式 ]
then
代码
elif [条件判断式]
then
代码
fi
```

![[imgs/Pasted image 20230323192213.png]]

### case 语句
基本语法：
```
case $变量名 in
"值 1"）
如果变量的值等于值 1，则执行程序 1
;;
"值 2"）
如果变量的值等于值 2，则执行程序 2
;;
*）
如果变量的值都不是以上的值，则执行此程序
;;
esac
```

![[imgs/Pasted image 20230323193147.png]]

### for 循环
基本语法 1
```
for 变量 in 值 1 值 2 值 3…
do
程序/代码
done
```
基本语法 2
```
for (( 初始值;循环控制条件;变量变化 ))
do
程序/代码
done
```

案例 1
![[imgs/Pasted image 20230323194249.png]]

案例 2 ：
![[imgs/Pasted image 20230323194721.png]]

### while 循环
基本语法：
```
while [ 条件判断式 ]
do
程序 /代码
done
```
while 和 [ 有空格，条件判断式和 [ 也有空格

案例：
![[imgs/Pasted image 20230323195224.png]]

### read 读取控制台输入
基本语法：
```
read(选项)(参数)
```

| 参数 | 作用                                                   |
| ---- | ------------------------------------------------------ |
| -p   | 指定读取值的提示符                                     |
| -t   | 指定读取值得等待时间（秒），如果没有指定，就不在等待了 |
| 参数 | 指定读取值的变量名                                                       |
案例：
![[imgs/Pasted image 20230323200024.png]]

## 函数
shell 编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。 

### 系统函数
basename 基本语法：
功能：返回完整路径最后 / 的部分，常用于获取文件名 
```
basename [pathname] [suffix]
basename [string] [suffix]
（功能描述：basename 命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。）
```
选项：
suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。

dirname 基本语法：
```
功能：返回完整路径最后 / 的前面的部分，常用于返回路径部分

dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩
下的路径（目录的部分））和 上面函数刚好相反

```

### 自定义函数
基本语法：
```
[ function ] funname[()]
{
   Action;
   [return int;]
}

调用直接写函数名：funname [值]
```

案例：计算两个数累加和
![[imgs/Pasted image 20230323202035.png]]

### 备份数据库
```
#备份目录
BACKUP=/data/backup/db
#当前时间
DATETIME=$(date +%Y-%m-%d_%H%M%S)
echo $DATETIME
#数据库的地址
HOST=localhost
#数据库用户名
DB_USER=root
#数据库密码
DB_PW=hspedu100
#备份的数据库名
DATABASE=hspedu
#创建备份目录, 如果不存在，就创建
[ ! -d "${BACKUP}/${DATETIME}" ] && mkdir -p "${BACKUP}/${DATETIME}"
#备份数据库
mysqldump
-u${DB_USER}
-p${DB_PW}
--host=${HOST}
-q
-R
--databases
${DATABASE}
|
gzip
>
${BACKUP}/${DATETIME}/$DATETIME.sql.gz
#将文件处理成 tar.gz
cd ${BACKUP}
tar -zcvf $DATETIME.tar.gz ${DATETIME}
#删除对应的备份目录
rm -rf ${BACKUP}/${DATETIME}
#删除 10 天前的备份文件
find ${BACKUP} -atime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "备份数据库${DATABASE} 成功~"
```

# 日志管理
日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。 

日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。

可以这样理解日志是用来**记录重大事件**的工具。

## 系统常用的日志
/var/log/ 目录就是系统日志文件的保存位置
![[imgs/Pasted image 20230324172304.png]]

系统常用日志
![[imgs/Pasted image 20230324173027.png]]

## 日志管理服务 rsyslogd
CentOS 7.6 日志服务是 rsyslogd ， CentOS 6. X 日志服务是 syslogd 。Rsyslogd 功能更强大。Rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容的。
原理示意图：
![[imgs/Pasted image 20230324173741.png]]


查询 Linux 中的 rsyslogd 服务是否启动：
```
ps aux | grep "rsyslog" | grep -v "grep"
这里 -v 代表反匹配，反向选择不含 grep的 
```

查询 rsyslogd 服务的自启动状态：
```
systemctl list-unit-files | grep rsyslog
```

配置文件：/etc/rsyslog.conf 的理解：
```
编辑文件时的格式为：
*.*
存放日志文件其中第一个*代表日志类型，第二个*代表日志级别
```
日志类型分为：
	Auth                                                   ##pam 产生的日志
	corn                                                     ##时间任务相关
	kern                                                     ##内核
	lpr                                                     ##打印
	mail                                                      ##邮件
	mark (syslog)-rsyslog                           ##服务内部的信息，时间标识
	news                                                       ##新闻组 
	user                                                      ##用户程序产生的相关信息 
	uucp ##unix to nuix copy              主机之间相关的通信 
	local 1-7                                       ##自定义的日志设备

日志级别：
	debug                         ##有调试信息的，日志通信最多 
	info                         ##一般信息日志，最常用 
	notice                      ##最具有重要性的普通条件的信息
	 warning                   ##警告级别 
	 err                            ##错误级别，阻止某个功能或者模块不能正常工作的信息 
	 crit                   ##严重级别，阻止整个系统或者整个软件不能正常工作的信息 
	 alert                  ##需要立刻修改的信息 
	 emerg                    ##内核崩溃等重要信息 
	 none                   ##什么都不记录
注意：从上到下，级别从低到高，记录信息越来越少 

由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下 4 列 
1) 事件产生的时间
2) 产生事件的服务器的主机名
3) 产生事件的服务名或程序名
4) 事件的具体信息


## 日志轮替
日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。

### 日志轮替文件命名
1. centos7 使用 logrotate 进行日志轮替管理，要想改变日志轮替文件名字，通过 /etc/logrotate. conf 配置文件中“dateext” 参数。
2. 如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如 “secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。 
3. 如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。***当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure. 1”，然后新建“secure”日志，用来保存新的日志***。 当第二次进行日志轮替时，“secure. 1” 会自动改名为“secure. 2”，当前的“secure”日志会自动改名为“secure. 1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。 


### logrotate 配置文件
/etc/logrotate. conf 为 logrotate 的全局配置文件：
```
# rotate log files weekly, 每周对日志文件进行一次轮替
weekly 

# keep 4 weeks worth of backlogs, 共保存 4 份日志文件，当建立新的日志文件时，旧的将会被删除
rotate 4 

# create new (empty) log files after rotating old ones, 创建新的空的日志文件，在日志轮替后 
create 

# use date as a suffix of the rotated file, 使用日期作为日志轮替文件的后缀
dateext 

# uncomment this if you want your log files compressed, 日志文件是否压缩。如果取消注释，则日志会在转储的同时进 行压缩
#compress 

#RPM packages drop log rotation information into this directory 
include /etc/logrotate.d
# 包含 /etc/logrotate.d/ 目录中所有的子配置文件。在这个路径下的配置文件也会读取进来。

#下面是对某个日志文件进行单独设置，优先级更高。
# no packages own wtmp and btmp -- we'll rotate them here 
/var/log/wtmp {
monthly     # 每月对日志文件进行一次轮替

create 0664 root utmp 
# 建立的新日志文件，权限是 0664 ，所有者是 root ，所属组是 utmp 组

minsize 1M 
# 日志文件最小轮替大小是 1MB 。也就是日志一定要超过 1MB 才会轮替，否则就算时间达到 一个月，也不进行日志转储

rotate 1 # 仅保留一个日志备份。也就是只有 wtmp 和 wtmp.1 日志保留

}

/var/log/btmp { 
missingok # 如果日志不存在，则忽略该日志的警告信息 
monthly 
create 0600 root utmp
rotate 1
}
```

Logrotata 配置文件参数
![[imgs/Pasted image 20230330183416.png]]

### 把自己日志文件加入到日志轮替
第一种方法是直接在/etc/logrotate. conf 配置文件中写入该日志的轮替策略

第二种方法是在/etc/logrotate. d/目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。

推荐使用第二种，可读性维护性更好。

例子：
在/etc/logrotate. conf 进行配置, 或者直接在 /etc/logrotate. d/ 下创建文件 hsplog 编写如下内容, 具体轮替的效果可以参考 /var/log 下的 boot. log 情况 
![[imgs/Pasted image 20230330184959.png]]

### 日志轮替机制原理
日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在 /etc/cron. daily/目录，就会发现这个目录中是有 logrotate 文件 (可执行)，logrotate 通过这个文件依赖定时任务执行的。 

## 查看内存日志
![[imgs/Pasted image 20230330185450.png]]
内存日志，重启就会被清空

# 定制自己的 Linux 系统
通过裁剪现有 Linux 系统 (CentOS7.6)，创建属于自己的 min Linux 小系统，可以加深我们对 linux 的理解。 

## 基本原理
启动流程介绍： 制作 Linux 小系统之前，
再了解一下 Linux 的启动流程： 
1、首先 Linux 要通过自检，检查硬件设备有没有故障 
2、如果有多块启动盘的话，需要在 BIOS 中选择启动磁盘 
3、启动 MBR 中的 bootloader 引导程序 
4、加载内核文件 
5、执行所有进程的父进程、老祖宗 systemd 
6、欢迎界面在 Linux 的启动流程中，加载内核文件时关键文件： 
	1）kernel 文件: vmlinuz-3.10.0-957. el7. x86_64
	2）initrd 文件: initramfs-3.10.0-957. el7. x86_64. img

# 内核源码介绍&内核升级
为什么要阅读 linux 内核?
可以对我们的开发有很大帮助。作为开发者，还是很有必要查看一下操作系统源码的。

## linux0.01 内核源码
Linux 的内核源代码可以从网上下载, 解压缩后文件一般也都位于 linux 目录下。内核源代码有很多版本，可以从 linux0.01 内核入手，总共的代码 1w 行左右，最新版本 5.9.8 总共代码超过 700w 行，非常庞大。

不要害怕阅读源码。

### linux0.01 内核源码目录&阅读
linux 内核源码阅读&目录介绍&main. c 说明：
![[imgs/Pasted image 20230331163406.png]]


系统入口主方法。
![[imgs/Pasted image 20230331164455.png]]

## linux 内核最新版和内核升级
升级内核首先要查看是否兼容

```
uname -a // 查看当前的内核版本

yum info kernel -q //检测内核版本，显示可以升级的内核

yum update kernel //升级内核

yum list kernel -q //查看已经安装的内核
```

# 系统-备份与恢复
实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，还会造成数据丢失。所以我们可以使用备份和恢复技术。

linux 的备份和恢复很简单，有两种方式：
- 把需要的文件 (或者分区)用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可。
- 使用 dump 和 restore 命令。


### 安装 dump 和 restore 
如果 linux 上没有 dump 和 restore 指令，需要先安装
```
yum -y install dump
yum -y install restor
有可能第一条指令就可以安装这个。

使用
dump，restore
指令查看。
```

## 使用 dump 完成备份
dump 支持分卷和增量备份（所谓增量备份是指备份上次备份后修改/增加过的文件，也称差异备份）。

```
dump [ -cu] [-123456789] [ -f <备份后文件名>] [-T <日期>] [ 目录或文件系统]

dump []-wW

-c  ： 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头。

-0123456789： 备份的层级。0 为最完整备份，会备份所有文件。若指定 0 以上的层级，则备份至上一次备份以来 修改或新增的文件, 到 9 后，可以再次轮替。
备份的层级的意思是，当用0制定一次备份后，新增文件后，再次制定备份，制定备份等级为1，他只会备份你修改和新增的文件。

-f <备份后文件名>： 指定备份后文件名

-j : 调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2 格式，让文件更小

-T <日期>： 指定开始备份的时间与日期

-u ： 备份完毕后，在/etc/dumpdares 中记录备份的文件系统，层级，日期与时间等。

-t ： 指定文件名，若该文件已存在备份文件中，则列出名称

-W ：显示需要备份的文件及其最后一次备份的层级，时间 ，日期。

-w ：与-W 类似，但仅显示需要备份的文件。

```

### dump 应用案例 
第一题
将/boot 分区所有内容备份到/opt/boot. bak0. bz2 文件中，备份层级为“0” 
```
dump -0uj -f /opt/boot.bak0.bz2 /boot
```

第二题：
在/boot 目录下增加新文件，备份层级为“1”(只备份上次使用层次“0”备份后发生过改变的数据), 注意比较看看这次生成的备份文件 boot1. bak 有多大。
```
dump -1uj -f /opt/boot.bak1.bz2 /boot
```
老韩提醒: 通过 dump 命令在配合 crontab 可以实现无人值守备份。

```
 dump -W
显示需要备份的文件及其最后一次备份的层级，时间，日期。
```


```
cat /etc/dumpdates
查看备份时间文件
```

### dump 备份文件或者目录
前面我们在备份分区时，是可以支持增量备份的，*如果备份文件或者目录，不再支持增量备份, 即只能使用 0 级别备份。*

如果是重要的备份文件，比如数据区，建议将文件上传到其它服务器保存，不要将鸡蛋放在同一个篮子。

### 使用 restore 完成恢复
restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件。

基本语法：
```
restore [模式选项] [选项]
```

![[imgs/Pasted image 20230402130208.png]]

-r 模式恢复那个文件只会恢复到那个文件的状态，加入进行了 0 1 备份，只恢复 1 他只会恢复 1 的文件，不会恢复 0 的文件，想完整恢复我们要把 0 也进行恢复。

# 可视化管理-webmin 和 bt 运维工具
## webmin
Webmin 是功能强大的基于 Web 的 Unix/linux 系统管理工具。管理员通过浏览器访问 Webmin 的各种管理功能并完成相应的管理操作。除了各版本的 linux 以外还可用于：AIX、HPUX、Solaris、Unixware、Irix 和 FreeBSD 等系统。 

### 安装 webmin&配置
1.  : [下载地址]( http://download.webmin.com/download/yum/ ) , 用下载工具下载即可
2. 也可以使用 wget http://download.webmin.com/download/yum/webmin-1.700-1.noarch.rpm

安装完成后，会有一个默认 root 用户，我们可以使用指令进行修改。
```
/usr/libexec/webmin/changepass.pl /etc/webmin root root
root 是 webmin 的用户名，不是 OS 的 , 这里就是把 webmin 的 root 用户密码改成了 root

```

修改 webmin 服务的端口号（默认是 10000） 出于安全目的。
```
vim /etc/webmin/miniserv.conf # 修改端

将 port=10000 修改为其他端口号，如 port=6666 和 listen也改为6666
```

重启 webmin
```
/etc/webmin/restart # 重启
/etc/webmin/start # 启动 
/etc/webmin/stop # 停止
```

防火墙放开 6666 端口
```
firewall-cmd --zone=public --add-port=6666/tcp --permanent
# 配置防火墙开放 6666 端口 

firewall-cmd --reload 
# 更新防火墙配置

firewall-cmd --zone=public --list-ports 
# 查看已经开放的端口号
```

登录 webmin，
```
http://ip:6666 可以访问了
使用root用户登录
```

### 简单使用演示
比如修改语言设置，IP 访问控制，查看进程, 修改密码，任务调度，mysql 等。


## bt (宝塔)
bt 宝塔 Linux 面板是提升运维效率的服务器管理软件，支持一键 LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA 等多项服务器管理功能。 

### 安装和使用

直接进入 [宝塔面板下载，免费全能的服务器运维软件 (bt.cn)](https://www.bt.cn/new/download.html),下载合适版本。

安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录。
```
外网面板地址: https://121.28.102.19:39122/a33b3f4b
内网面板地址: https://192.168.200.130:39122/a33b3f4b
username: zml001
password: 123456
```


安装的软件：
**Tomcat
Zookeeper
Nginx**

自己研究使用，功能很强大。







